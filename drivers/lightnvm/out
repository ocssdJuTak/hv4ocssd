--- pblk-gc.c	2018-01-29 06:20:33.000000000 +0900
+++ /home/tak/jolp_l/jutak/linux/drivers/lightnvm/pblk-gc.c	2018-05-17 16:27:13.450716442 +0900
@@ -25,10 +25,14 @@
 	kfree(gc_rq);
 }
 
+// pblk->gc에서 w_list에 있는 요청을 꺼내서 gc_write를 실행
 static int pblk_gc_write(struct pblk *pblk)
 {
 	struct pblk_gc *gc = &pblk->gc;
 	struct pblk_gc_rq *gc_rq, *tgc_rq;
+
+	//#define LIST_HEAD(name) \
+		struct list_head name = LIST_HEAD_INIT(name)
 	LIST_HEAD(w_list);
 
 	spin_lock(&gc->w_lock);
@@ -36,26 +40,32 @@
 		spin_unlock(&gc->w_lock);
 		return 1;
 	}
+	// write할 것이 있다면 현재 gc->w_lock을 획득한 상태
 
+	// list가 circular-doubly list이기 때문에, 
+	// 아래 명령은 gc->w_list를 전부 w_list에 옮기는게 아닐까
 	list_cut_position(&w_list, &gc->w_list, gc->w_list.prev);
 	gc->w_entries = 0;
 	spin_unlock(&gc->w_lock);
 
-	list_for_each_entry_safe(gc_rq, tgc_rq, &w_list, list) {
+	list_for_each_entry_safe(gc_rq, tgc_rq, &w_list, list) {		// tgc_rq == temporary_gc_rq
 		pblk_write_gc_to_cache(pblk, gc_rq);
 		list_del(&gc_rq->list);
 		kref_put(&gc_rq->line->ref, pblk_line_put);
 		pblk_gc_free_gc_rq(gc_rq);
+
 	}
 
 	return 0;
 }
 
+// gc_writer_ts를 시동하는 함수
 static void pblk_gc_writer_kick(struct pblk_gc *gc)
 {
 	wake_up_process(gc->gc_writer_ts);
 }
 
+// 해당 line을 상황에 맞는 gc_list의 뒤에 붙임
 static void pblk_put_line_back(struct pblk *pblk, struct pblk_line *line)
 {
 	struct pblk_line_mgmt *l_mg = &pblk->l_mg;
@@ -86,7 +96,7 @@
 	struct pblk_gc_rq *gc_rq = gc_rq_ws->priv;
 	int ret;
 
-	up(&gc->gc_sem);
+	up(&gc->gc_sem);	// sema up
 
 	gc_rq->data = vmalloc(gc_rq->nr_secs * geo->sec_size);
 	if (!gc_rq->data) {
@@ -169,7 +179,14 @@
 	 * the line untouched. TODO: Implement a recovery routine that scans and
 	 * moves all sectors on the line.
 	 */
-	lba_list = pblk_recov_get_lba_list(pblk, emeta_buf);
+
+	ret = pblk_recov_check_emeta(pblk, emeta_buf);
+	if (ret) {
+		pr_err("pblk: inconsistent emeta (line %d)\n", line->id);
+		goto fail_free_emeta;
+	}
+
+	lba_list = emeta_to_lbas(pblk, emeta_buf);
 	if (!lba_list) {
 		pr_err("pblk: could not interpret emeta (line %d)\n", line->id);
 		goto fail_free_emeta;
@@ -260,6 +277,8 @@
 	pr_err("pblk: Failed to GC line %d\n", line->id);
 }
 
+// 해당 line을 gc_reader_wq에 등재함
+// 성공시 0
 static int pblk_gc_line(struct pblk *pblk, struct pblk_line *line)
 {
 	struct pblk_gc *gc = &pblk->gc;
@@ -286,6 +305,7 @@
 	wake_up_process(gc->gc_reader_ts);
 }
 
+// gc를 시동하는 함수(kick은 "~을 시작하는 함수"에 쓰임)
 static void pblk_gc_kick(struct pblk *pblk)
 {
 	struct pblk_gc *gc = &pblk->gc;
@@ -301,6 +321,7 @@
 	}
 }
 
+// r_list의 첫 line에 대해 gc를 시작
 static int pblk_gc_read(struct pblk *pblk)
 {
 	struct pblk_gc *gc = &pblk->gc;
@@ -519,22 +540,12 @@
 	}
 }
 
-/*
- * If flush_wq == 1 then no lock should be held by the caller since
- * flush_workqueue can sleep
- */
-static void pblk_gc_stop(struct pblk *pblk, int flush_wq)
-{
-	pblk->gc.gc_active = 0;
-	pr_debug("pblk: gc stop\n");
-}
-
 void pblk_gc_should_stop(struct pblk *pblk)
 {
 	struct pblk_gc *gc = &pblk->gc;
 
 	if (gc->gc_active && !gc->gc_forced)
-		pblk_gc_stop(pblk, 0);
+		gc->gc_active = 0;
 }
 
 void pblk_gc_should_kick(struct pblk *pblk)
@@ -579,6 +590,8 @@
 	struct pblk_gc *gc = &pblk->gc;
 	int ret;
 
+	// ts : task struct
+	// kthread : kernel thread
 	gc->gc_ts = kthread_create(pblk_gc_ts, pblk, "pblk-gc-ts");
 	if (IS_ERR(gc->gc_ts)) {
 		pr_err("pblk: could not allocate GC main kthread\n");
@@ -602,12 +615,15 @@
 	}
 
 	timer_setup(&gc->gc_timer, pblk_gc_timer, 0);
+	// timer modify
+	// cf) jiffy는 linux의 시간 단위
+	// http://hbisland.tistory.com/entry/kernel-시간관리
 	mod_timer(&gc->gc_timer, jiffies + msecs_to_jiffies(GC_TIME_MSECS));
 
 	gc->gc_active = 0;
 	gc->gc_forced = 0;
 	gc->gc_enabled = 1;
-	gc->w_entries = 0;
+	gc->w_entries = 0;			// TODO: w_entries의 의미?
 	atomic_set(&gc->read_inflight_gc, 0);
 	atomic_set(&gc->pipeline_gc, 0);
 
@@ -631,6 +647,7 @@
 		goto fail_free_reader_line_wq;
 	}
 
+	// lock을 잡는 순서가 중요할까?
 	spin_lock_init(&gc->lock);
 	spin_lock_init(&gc->w_lock);
 	spin_lock_init(&gc->r_lock);
@@ -660,7 +677,7 @@
 
 	gc->gc_enabled = 0;
 	del_timer_sync(&gc->gc_timer);
-	pblk_gc_stop(pblk, 1);
+	gc->gc_active = 0;
 
 	if (gc->gc_ts)
 		kthread_stop(gc->gc_ts);
